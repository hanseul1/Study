**1. 데이터베이스의 구성요소는?**

 

\- 데이터 베이스의 구성요소에는 3가지가 있다.

 \1. 개체(Entity) 2. 속성(Attribute) 3. 관계(relationship)

\- 개체 : DB에서 표현하고자하는 유, 무형의 객체 -> 저장, 관리되어야하는 데이터의 집합 :: 테이블

\- 속성 : 개체의 특성이나 상태 :: 컬럼(column)

\- 관계 : 개체와 개체 또는 개체와 속성간의 관계

 

**2. RDBMS는 무엇인가?**

 

\- 관계형 데이터베이스로써, 데이터가 논리적인 값에의한 관계를 가진 것을 말한다.

\- 데이터 검색을 위해 관계형 연산을 지원하는 SQL명령어를 사용한다.

 

2.1 NoSQL은 무엇인가?

\- NoSQL은 데이터 검색과 삽입의 속도 향상에 특화된 목적을 위해 비관계형 데이터 저장소에 데이터를 저장하는 분산 저장 시스템이다.

\- 관계형 모델을 사용하지 않으므로 테이블간의 조인 기능이 없다.

\- 비 SQL 인터페이스를 통한 데이터 액세스를 지원한다.

\- 여러 대의 DB 서버를 묶어 하나의 데이터베이스를 구성한다.(DB 클러스터링)

\- 기존 관계형 데이터베이스의 트랜잭션에서 제공하는 ACID 특성을 지원하지 않는다.

 

2.2 NoSQL은 왜 사용할까?

\- SNS나 온라인 쇼핑몰 서비스같이 실시간으로 데이터가 빠르게 쌓이는 서비스가 증가하면서 NoSQL의 사용성이 증가했다.

\- 다수의 클라이언트가 동시에 데이터를 읽고 쓰는 상황에서 성능 향상을 위해 사용할 수 있다.

 

2.3 NoSQL에서 사용하는 모델에 대해서 설명해보라.

\- NoSQL에서 사용하는 모델에는 크게 4가지가 있다.

 : Key-Value, Document, Column-Family, Graph

\- Key-Value : 가장 대표적으로 사용하는 모델로써, 데이터를 키와 값 쌍으로 저장하는 모델이다.

​         RDBMS의 PK를 키값으로 하고 다른 속성값들을 값으로 하여 각 로우에 저장한다.

​         value값은 어떠한 형태도 가능하지만 값의 내용을 사용한 쿼리가 불가능하다는 단점이 있다.

​         ex ) Redis

\- Document : 데이터를 키와 도큐먼트의 형태로 저장하는 모델이다.

​          테이블 대신 Collection에 Document를 XML이나 JSON 같은 형태로 저장한다.

​          ex) MongoDB, FireBase

\- Column-Family : 각 데이터가 각자의 column-name을 가지고 column-family에 속하여 저장된 형태의 모델이다.

​             RDBMS의 속성들이 계층적인 구조를 가지고 있어 각 데이터에 맞는 속성을 가질 수 있다.

 

**3. PK와 FK에 대해 설명하라.**

 

\- Primary Key는 테이블의 각 튜플을 유일하게 식별해주는 속성의 조합이다.

 일반적으로 변경되지 않는 값으로 정한다.

\- Foreign Key는 같은 테이블 또는 다른 테이블의 PK를 참조하는 속성의 조합이다.

  이는 논리적인 값에 의한 것일뿐 물리적으로 pointer가 존재하지 않는다.

  FK는 참조하는 PK의 값이나 NULL값만 허용한다.

 

**4. SQL 명령어의 종류**

 

\- SQL 명령어의 종류에는 크게 3가지가 있다 : DDL, DML, DCL

\- DDL(Data Definition Language) : 테이블 생성이나 구조 변경, 삭제 등의 데이터 구조에 관한 명령어

\- DML(Data Manipulation Language) : 데이터 조작에 관한 명령어(insert, update, delete,..)

\- DCL(Data Control Language) : DB에 접근하고 데이터를 사용하도록 권한을 주고받는 명령어(grant, revoke)

\- rollback, commit은 TCL(Transaction Control Language)

 

**5. delete, truncate, drop의 차이점은?**

 

\- delete : 원하는 데이터만 삭제할 수 있고, rollback할 수 있다.

\- truncate : 데이터를 선택해서 삭제할 수 없고, rollback할 수 없다. 

​        테이블은 남아있고 데이터만 삭제된다.

\- drop : 테이블 전체를 삭제한다. rollback할 수 없다.

 

**6. Join의 개념과 종류에 대해 설명하라.**

 

\- 하나 이상의 테이블로부터 연관된 데이터를 검색해오는 방법이다.

\- 조인은 크게 세가지로 나눌 수 있다. -> inner join과 outer join, self join

 

\* inner join

\- 기본 조인 형식으로써 두개의 테이블의 컬럼값을 결합하여 새로운 결과 테이블을 생성한다.

\- equi join, cross join, natural join이 있다.

\- equi join : 동등 비교를 통해 결과 테이블을 생성한다.

\- natural join : 컬럼명이 같은 컬럼에 대해 비교를 통해 결과 테이블을 생성한다.

​          (결과 테이블에서 동일한 컬럼명을 가지고 있는 컬럼은 유일하게 추출된다.)

\- cross join : 곱집합(카티시안곱) 결과로 결과 테이블을 생성한다.

 

\* outer join

\- 조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요한 상황일 때 그 테이블을 기준으로 조인하여 결과 테이블을 생성한다.

\- left outer join과 right outer join이 있다.

 

\* self join

\- 한 테이블이 자기 자신과 조인하여 결과 테이블을 생성한다.

 

**7. savepoint의 개념에 대해서 설명하라.**

 

\- savepoint는 트랜잭션 중간에 위치를 지정하여 특정 지점까지 rollback 할 수 있는 명령어이다.

\- 현재 트랜잭션을 더 작은 단위로 나눌 수 있게된다.

 

**8. View란 무엇인가?**

 

\- view는 테이블이나 다른 뷰를 기초로한 논리적인 가상 테이블이다.

\- 실제 데이터는 없고 질의 문장만 가지고 있다.

\- 허용된 데이터만 제한적으로 보여줌으로써 보안측면으로 활용할 수 있다.

 

8.1 뷰를 생성한 기본 테이블이 변경되면 뷰도 함께 변경해주어야 하는가?

\- 아니다. 기본 테이블 데이터가 변경되면 뷰도 자동적으로 변경된다.

+) 뷰가 정의된 기본테이블이나 다른 뷰가 삭제되면 해당 뷰도 함께 삭제된다.

 

8.2 뷰를 사용하는 이유는 무엇인가?

\- 실제 데이터 테이블에 접근하지 않고 가상 테이블의 데이터만 보여주기 때문에 접근 제어가 가능해 보안 유지를 할 수 있다.

\- 복잡한 쿼리문의 경우 한번 생성해놓고 재사용함으로써 편의성을 증가시켜준다.

 

**9. Index란 무엇인가?**

 

\- 인덱스란 테이블에 대한 명령어 수행 속도를 높여주는 자료구조이다.

\- 인덱스는 테이블의 일부 컬럼의 조합으로 하나의 또 다른 테이블을 생성하여 특정 기준으로 정렬한다.

 => 각 행의 주소(rowid)와 인덱스 컬럼값으로 이루어져있다.

\- 내부적으로 B-Tree 구조로 데이터를 저장하기 때문에 특정 컬럼값을 찾아내는 것이 빠르다.

 => 해당 노드가 가지고있는 rowid값으로 기존 테이블에서 조회하면 나머지 컬럼값도 조회 가능하다.

   (rowid는 데이터를 삽입할 때 DB 내부에서 자동으로 생성하는 값으로 rowid가 주어지면 해당 행의 데이터로 바로 접근이 가능하다)

\- MySQL은 기본적으로 PK에 대한 인덱스 테이블을 생성한다.

 

9.1 인덱스를 주로 어떤 때 사용하는가?

\- where 조건이나 join 조건으로 특정 컬럼을 기준으로 많이 사용할 때와 컬럼이 많을 때 주로 사용할 수 있다.

\- 테이블의 데이터가 방대하고 테이블에서 주로 조회되는 행의수가 전체의 5% 미만일 때 효율적으로 사용할 수 있다.

 

9.2 인덱스의 단점이 있을까?

\- 인덱스도 결국 테이블이 생성되는 것이므로 너무 많은 컬럼 조합에 대해서 인덱스를 생성하면 메모리 낭비가 생기게된다.

\- select를 제외한 insert, update, delete의 경우 관련 인덱스 테이블에서 새롭게 데이터를 정렬해야 하므로 성능이 저하된다.

 => 많은 컬럼을 인덱스로 남용하지 않는 것이 좋다.

 

더보기

 

**10. 데이터베이스 트랜잭션의 개념과 성질에 대해 설명해보라.**

 

\- 트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위이다.

\- 하나의 트랜잭션은 여러개의 SQL 명령어로 이루어질 수 있다.

 => 하나의 트랜잭션은 commit되거나 rollback된다.

 

\- 트랜잭션의 성질에는 4가지가 있다 : ACID

Atomicity (원자성) : 트랜잭션의 모든 연산들은 모두 수행되거나 모두 수행되지 않아야한다.

Consistency (일관성) : 트랜잭션이 완료된 후에도 데이터베이스 상태가 일관되게 유지되어야 한다.

​               즉, 데이터 모델의 모든 제약조건(PK, FK 등)이 트랜잭션 후에도 만족해야 한다.

Isolation (격리성) : 하나의 트랜잭션은 독립적으로 수행된다.

​             즉, 하나의 트랜잭션이 실행 중 변경한 데이터는 트랜잭션 수행이 완료될 때까지 다른 트랜잭션이 참조하지 못한다.

Durability (지속성) : commit된 트랜잭션의 결과는 영원히 반영되어야 한다.

 

10-1. 트랜잭션의 독립성을 보장하기 위한 방법에는 무엇이 있는가?

\- 병행 처리되는 트랜잭션들간의 독립성을 보장하기 위해 lock & excute  unlock 방식을 사용한다.

\- 데이터를 읽을 때는 다른 여러 트랜잭션이 동시에 데이터를 읽을수 있도록 shared_lock을 한다.(쓰기는 불가능하다)

\- 데이터를 쓸 때는 다른 어떤 트랜잭션이 쓰거나 읽을 수 없도록 exclusive_lock을 한다.

\- 특정 데이터에 대한 작업이 끝나면 unlock을 통해 다른 트랜잭션의 접근을 허용하도록 한다.

 

10-2. 트랜잭션의 독립성이 보장되지 않은 경우 발생할 수 있는 문제에 대해서 설명하라.

\- 크게 4개의 트랜잭션의 격리 수준에 따라 다른 현상이 발생한다.

\1. 레벨 0 : Read Uncommitted

 \- 트랜잭션이 처리중인 데이터에 대해서 shared_lock을 걸지않고 접근을 허용하는 레벨

 \- 수정중인 데이터를 읽을 수 있어 일관성을 유지할 수 없다.

 => Dirty Read 발생

 

\2. 레벨 1 : Read Committed

 \- 트랜잭션의 쿼리문(select)이 수행중일 때 같은 데이터에 접근하지 못하게 shared_lock을 거는 레벨

 \- commit이 완료된 데이터만 읽을 수 있다.

 \- 많은 SQL 서버가 지원하는 격리 수준 레벨

 \- 한 트랜잭션 내에서 같은 쿼리문을 두번 이상 수행할 때 그 사이에 다른 트랜잭션이 데이터를 수정 또는 삭제하면 각 쿼리의 결과들이 다르게 나와 일관성을 유지할 수 없다.

 => Non-Repeatable Read 발생

 

\3. 레벨 2 : Repeatable Read

 \- 트랜잭션이 완료될 때까지 select 문장이 사용하는 모든 데이터에 shared_lock을 거는 레벨

 \- 한 트랜잭션 내에서 같은 쿼리는 같은 결과를 보장하도록 한다.

  즉, 다른 트랜잭션이 해당 데이터에 대해서 수정 또는 삭제할 수 없다.

 \- 새로운 데이터가 삽입되면 이전 쿼리 결과에는 없었던 데이터가 다음 쿼리 결과에 나타나게 된다.

 => Phantom Read 발생

 

\4. 레벨 3 : Serializable

 \- 트랜잭션이 완료될 때까지 해당 테이블에 다른 트랜잭션이 데이터 삽입, 수정, 삭제를 하지 못하도록 하는 레벨

 \- 완벽한 일관성을 제공하지만 병행 처리가 힘들어 동시성이 떨어지게 된다.

 

 

**11. 데이터베이스 정규화에 대해서 설명하라.**

 

\- 정규화는 데이터베이스의 테이블을 일정 기준으로 분리함으로써 데이터의 중복을 제거하고, 이상현상을 방지하는 과정이다.

\- 또한, 불필요한 쿼리 제거로 성능을 향상시킬 수 있다.

 

더보기

\* 1차 정규화 : 각 로우의 컬럼값이 원자값을 갖도록 하는 과정이다.

​          즉, 컬럼값이 2개이상인 로우가 있을 경우 로우를 추가하여 분리한다.

​         => 데이터 중복이 생기지만 논리적 구성을 위해 trade-off 한다.

 

\* 2차 정규화 : 모든 컬럼이 완전 함수 종속성을 만족하도록 하는 과정이다.

​          기본키 집합 중 일부 컬럼에만 종속된 컬럼이 존재하는 경우 부분적 종속성을 가지게 된다.

​          이 부분적 종속을 없애기 위해 해당 종속 컬럼과 그 결정자(기본키 부분집합)를 다른 테이블로 분리한다.

 

\* 3차 정규화 : 기본키를 제외한 컬럼들 간의 이행적 함수 종속성을 제거하는 과정이다.

​          기본키 이외의 다른 컬럼이 그 외 다른 컬럼을 결정하면 이행적 함수 종속성을 가지게 된다.

​          이 이행적 종속을 없애기 위해 해당 종속 컬럼과 그 결정자를 다른 테이블로 분리한다.

 

\* BCNF : 3차 정규형을 좀 더 강화하는 과정이다.

​      모든 결정자가 후보키 집합에 속하도록 한다.

​      3차 정규형을 만족하면서 BCNF를 만족하지 않는 경우는 일반 컬럼이 후보키를 결정하는 경우이다.

​      이 때 해당 결정자와 후보키를 다른 테이블로 분리하여 정규화 한다.

 

참고 : https://3months.tistory.com/193

[ 데이터베이스 정규화 1NF, 2NF, 3NF, BCNF데이터베이스 정규화 1NF, 2NF, 3NF, BCNF 데이터베이스 정규화란 데이터베이스의 설계를 재구성하는 테크닉입니다. 정규화를 통해 불필요한 데이터(redundancy)를 없앨 수 있고, 삽입/갱신/삭제 시 발생할 수 있..3months.tistory.com](https://3months.tistory.com/193)

 

11-1. 정규화는 무조건 좋은가?

\- 그렇지 않다. 정규화된 테이블은 중복을 제거하기 때문에 용량이 줄어드는 효과가 있지만, 데이터 처리 속도가 느려질 수도 있다. 또한, 복잡한 쿼리문을 작성해야 하는 단점이 있다.

\- 느려지는 경우의 대표적인 예는 join 연산이다.

\- 정규화 과정에서 너무 많은 릴레이션의 분리가 일어나면 많은 join 연산을 수행해야 하고, 이는 데이터 조회 속도가 느려지게 되는 원인이 된다.

 

11-2. 정규화의 단점을 극복하는 방안에는 무엇이 있는가?

\- 반정규화(역정규화)를 통해서 분리했던 테이블을 통합하는 과정을 수행한다.

\- 특히 자주 사용되는 테이블에 접근하는 프로세스의 수가 많은 경우, 대량 데이터의 대량의 범위를 자주 처리하는 경우 사용할 수 있다.

 

\- 반정규화를 과도하게 적용하면 데이터의 무결성이 깨질 수 있다. 

\- 또한, 데이터 조회 이외의 삽입, 수정, 삭제시에 수행시간이 오래 걸릴 수 있다. 

  => 이 경우 무리한 반정규화보다 View를 통한 복잡한 쿼리문 문제 해결과 클러스터링 또는 인덱스를 통한 조회 시간 단축을 할 수 있는지 확인하는 것도 좋다.

 

**12. 데이터베이스 Connection Pool 에 대해 설명하라.**

 

\- Connection Pool은 데이터베이스에 접근하기 위한 Connection을 미리 생성해두어 저장해놓은 캐시 공간이다.

\- DB Connection에 대한 요청이 오면 커넥션 풀의 커넥션 하나를 빌려주고 다시 반납받는 방식으로 운영한다.

\- 미리 커넥션을 생성해놓기 때문에 요청이 들어올 때마다 커넥션 생성과 소멸하는 과정을 생략하여 성능 향상을 기대할 수 있다.

 

**13. DB 파티셔닝이란 무엇인가?**

 

\- 큰 테이블이나 인덱스를 작은 단위로 물리적으로 분할함으로써 대규모 데이터베이스의 성능 저하 문제를 해결하는 과정이다.

\- 각 파티션을 독립적으로 백업, 복구할 수 있어 효율적인 관리가 가능하다.

\- 많은 insert 작업들을 파티션들로 분산시켜 효율적으로 수행한다. (삽입, 수정, 삭제 작업의 분산)

\- 테이블간 조인 비용이 추가적으로 발생하는 단점이 있다.

\- 수평 파티셔닝과 수직 파티셔닝이 있다.

 

13-1. 수직 파티셔닝과 정규화의 차이점?

\- 둘 다 테이블의 컬럼을 분리한다는 공통점이 있지만, 수직 파티셔닝은 이미 정규화된 테이블을 분리하는 과정이다.

 

 

14. **데이터베이스 설계 과정에 대해서 설명하라.**

\- 데이터베이스 설계에는 크게 3가지가 있다. : 개념적 설계, 논리적 설계, 물리적 설계

\- 개념적 설계 : 사용자 요구사항에서 데이터를 구조화하여 E-R 다이어그램을 작성하는 단계

\- 논리적 설계 : 특정 DBMS의 논리적 자료 구조로 변환하는 과정. 테이블을 설계하고 정규화하는 단계

\- 물리적 설계 : 데이터를 물리적 구조로 변환하는 과정. 